# 库文件的编译及链接

> 库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。
> 本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种：静态库（.a）和动态库（.so）。

## 静态库

* <font color=red>简介</font>
    * 之所以成为【静态库】，是因为在链接阶段，会将汇编生成的目标文件 .o 与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。
    * 试想一下，静态库与汇编生成的目标文件一起链接为可执行文件，那么静态库必定跟.o文件格式相似。其实一个静态库可以简单看成是一组目标文件（.o/.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件。

* <font color=red>特点</font>
    * 静态库对函数库的链接是放在编译时期完成的。
    * 程序在运行时与函数库再无瓜葛，因为可执行程序已经包含库函数内的信息，移植方便。
    * 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。

* <font color=red>命名规则</font>
Linux静态库命名规范，必须是 “lib[your_library_name].a”：lib为前缀，中间是静态库名，扩展名为.a。
例如，创建一个名为 test 的静态库，其命名为 libtest.a。

* <font color=red>静态库的创建</font>
    Linux下使用 **ar** 指令进行静态库操作。
    假如有 a.c b.c c.c 三个源文件，如要将其封装成一个静态库文件 libtest.a 具体创建步骤如下：
    1. 首先，将源文件编译成目标文件.o （a.o b.o c.o）
    `gcc -c a.c b.c c.c`

    2. 通过 ar 指令将目标文件打包成 .a 静态库文件
    `ar -crv libtest.a a.o b.o c.o`

* <font color=red>静态库的使用</font>
    Linux下使用静态库，只需要在编译的时候，指定静态库的搜索路径（-L选项）、指定静态库名（不需要lib前缀和.a后缀，-l选项）。

    举例：源文件 main.c，需要链接 libtest.a 静态库，生成可执行程序 main，静态库在 ./lib 目录下，其头文件在 ./include 路径下：
    `gcc -o main main.c -L./lib -ltest -I./include`

* <font color=red>多个静态库合成一个静态库</font>
    有时一个程序需要链接多个静态库文件，比较混乱，需要将多个静态库文件合成一个静态库文件。
    举例：现有 liba.a libb.a libc.a 三个静态库文件，需要将其合成为 libone.a：
    1. 使用 ar 指令的 "x" 选项，将原有静态库文件拆解为目标文件(.o)。
        ```c
        ar x liba.a
        ar x libb.a
        ar x libc.a
        ```
    2. 通过 ar 指令将目标文件打包成 .a 静态库文件
    `ar -crv libone.a *.o`